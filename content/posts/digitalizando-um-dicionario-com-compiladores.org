#+TITLE: Do PDF de um dicion√°rio √† um aplicativo para estudo de Vocabul√°rio com Compiladores
#+DATE: <2024-07-06>

J√° fazem muitos anos que n√£o tenho dificuldade nas leituras em Ingl√™s de livros t√©cnicos, e isso tem um motivo, o vocabul√°rio destes livros √© altamente especializado, uma vez aprendido e pronto, a maioria dos livros podem ser lidos sem maiores dificuldades. O mesmo n√£o √© verdade toda vez que inicio estudos de assuntos diferentes como literatura, filosofia, hist√≥ria ou economia. Ao adentrar em um novo campo de estudos me pego parando a leitura in√∫meras vezes para aprender o vocabul√°rio do livro. Durante a leitura normalmente recorro a ferramentas de tradu√ß√£o online. Neste processo notei que tenho uma grande dificuldade em decorar um pequeno conjunto de palavras, pesquiso a mesma palavra in√∫meras vezes antes de decor√°-la, ou seja, lembro que j√° pesquisei a tradu√ß√£o de determinadas palavras, embora ainda n√£o lembre de seu significado. Criei listas de palavras para decor√°-las mas logo percebi o qu√£o ineficiente era este processo, ent√£o meu instinto de programador pensou em uma √∫nica palavra: automa√ß√£o.

A maneira mais eficiente que encontrei de obter o significado de palavras durante a leitura sem perder o foco √© utilizando aplicativos de tradu√ß√£o. Para automatizar meu processo de decorar o vocabul√°rio que tenho mais dificuldade projetei a cria√ß√£o de um aplicativo que:

- Replicasse a experi√™ncia de aplicativos de tradu√ß√£o com os quais eu estava acostumado;
- Cada palavra pesquisada seria adicionada a uma lista de palavras para treinar com um √≠ndice de de pesquisas de forma a cirar uma lista de prioridade das palavras que mais pesquiso;
- Uma tela de treinamento para terinar o aprendizado destas palavras de forma r√°pido, cada erro ou acerto atualizaria o √≠ndice daquela palavra at√© ao ponto em que a palavra poderia ser removida da lista de treinamento quando fosse decorada.

A implementa√ß√£o de um aplicativo como este √© razoavelmente simples, basta obter alguma API de tradu√ß√£o - de alguma plataforma tradicional ou j√° que estamos em tempos de /AI/, alguma API baseada em um modelo /LLM/. No entanto, eu defini alguns requisitos que precisavam ser atendidos:

- O App n√£o deveria gerar custos financeiros;
- A implementa√ß√£o deveria ser divertida ü•∏.

Bem, a implementa√ß√£o via API n√£o se encaixa em nenhum destes requisitos üòÖ. N√£o era necess√°rio a implemena√ß√£o de um sistema de tradu√ß√£o completo, era necess√°rio apenas um dicion√°rio, essa constata√ß√£o simplifica por ordens de grandeza o problema. Procurei por dicion√°rios digitalizados na internet mas n√£o encontrei nada muito completo, era preciso digitalizar um dicion√°rio. Para solucionar este problema era necess√°rio converter o PDF do dicion√°rio em texto e a partir do texto estruturar um mapa como ~palavra em ingl√™s => tradu√ß√µes~.

* Transformando PDF em texto

Tentei n√£o perder muito tempo com esta etapa recorrendo a ferramentas online, mas n√£o demorei muito para perceber um problema, dicion√°rios s√£o divididos em 2 colunas, e estas ferramentas n√£o entendem isso. O texto √© gerado considerando uma √∫nica coluna. Era preciso de alguma maneira realizar este processo de maneira diferente, para cada p√°gina, gerar o texto da coluna da esquerda e depois o da direita:

#+DOWNLOADED: screenshot @ 2024-07-06 17:52:50
[[file:Transformando_PDF_em_texto/2024-07-06_17-52-50_screenshot.png]]

A biblioteca [[https://itextpdf.com/][iText]] permite realizar este processamento de forma muito simples, basta gerar √°reas representando cada coluna para realizar a extra√ß√£o dos textos de forma separada. A classe em Java abaixo demonstra como realizar a convers√£o de um dicion√°rio em PDF para um arquivo texto especificando os limites via constantes e as p√°ginas de interesse via par√¢metros do m√©todo /parse/:

#+begin_src java

  package com.lang.trainer.dictionaries;

  import com.itextpdf.text.Rectangle;
  import com.itextpdf.text.pdf.PdfReader;
  import com.itextpdf.text.pdf.parser.*;

  import java.io.FileOutputStream;
  import java.io.IOException;
  import java.nio.file.Files;
  import java.nio.file.Path;
  import java.util.List;
  import java.util.function.Function;
  import java.util.stream.Stream;

  class PdfParser implements AutoCloseable {
      private static final byte[] NL = "\n".getBytes();

      private static final int VERTICAL_MARGIN = 38;
      private static final int X_MAX = 432;
      private static final int Y_MAX = 663;

      private final Path pdfPath;
      private final Path outPath;
      private final Path tmpPath;

      RoutledgePdfParser(Path pdfPath, Path outPath) throws IOException {
          this.pdfPath = pdfPath;
          this.outPath = outPath;
          Files.deleteIfExists(outPath);
          Files.createFile(outPath);

          tmpPath = Path.of(outPath + ".tmp");
          Files.createFile(tmpPath);
      }

      public void parse(int startPage, int endPage) throws IOException {
          PdfReader reader = new PdfReader(pdfPath.toString());
          float middlePdfPage = ((float) X_MAX / 2) + 2;
          Rectangle leftColumn = new Rectangle(
                  0, VERTICAL_MARGIN,
                  middlePdfPage, Y_MAX - VERTICAL_MARGIN);
          Rectangle rightColumn = new Rectangle(
                  middlePdfPage, VERTICAL_MARGIN,
                  X_MAX, Y_MAX - VERTICAL_MARGIN);

          try (FileOutputStream tempOutStream = new FileOutputStream(tmpPath.toString())) {
              for (int i = startPage; i <= endPage; i++) {
                  tempOutStream.write(extractText(reader, leftColumn, i).getBytes());
                  tempOutStream.write(NL);
                  tempOutStream.write(extractText(reader, rightColumn, i).getBytes());
                  tempOutStream.write(NL);
              }
          }

          try (
  		   Stream<String> linesStream = Files.lines(tmpPath);
  		   FileOutputStream outStream = new FileOutputStream(outPath.toString())) {
  			String[] lines = linesStream.forEach(l -> {
  					outStream.write(cleaned.getBytes());
  					outStream.write("\n".getBytes());
  				});
          }
      }

      private String extractText(PdfReader reader, Rectangle region, int pageNumber) throws IOException {
          RenderFilter[] filter = {new RegionTextRenderFilter(region)};
          TextExtractionStrategy strategy = new FilteredTextRenderListener(
                  new LocationTextExtractionStrategy(), filter);
          return PdfTextExtractor.getTextFromPage(reader, pageNumber, strategy);
      }

      @Override
      public void close() throws IOException {
          Files.deleteIfExists(tmpPath);
      }
  }

#+end_src

* Estruturando o texto em um mapa de tradu√ß√µes

√â nesta etapa que a divers√£o come√ßa. Dicion√°rios tem uma estrutura muito bem definida e cientistas da computa√ß√£o sabem h√° anos como analisar este tipo de texto: compiladores. Um exemplo disso s√£o linguagens de programa√ß√£o,independente de qual voc√™ utilize, por tr√°s sempre haver√° um compilador ou interpretador respons√°vel por transformar seu programa em uma linguagem de m√°quina que o computador possa executar. No caso de linguagens interpretadas, n√£o existe um compilador, mas sim um interpretador que interpreta cada comando fornecido para a gera√ß√£o de um resultado. No caso de linguagens compiladas, antes da execu√ß√£o do programa, todo o c√≥digo √© traduzido (compilado) para uma linguagem de mais baixo n√≠vel. Compiladores completos traduzem para uma linguagem de montagem final como Assembly. No entanto, como temos compiladores muito maduros para linguagens como C, outra abordagem √© realizar a tradu√ß√£o para uma linguagem intermedi√°ria a aproveitar-se de otimiza√ß√µes existentes nestes compiladores para gerar o c√≥digo de linguagem de m√°quina final.

De forma muito grosseira, compiladores utilizam-se de gram√°ticas para analisar textos estruturados. O processo consiste na constru√ß√£o de uma /parse tree/ que representa o conte√∫do do texto de acordo com os elementos da gram√°tica. Um exemplo simples para ilustrar todo esse processo √© a an√°lise de arquivos JSON, funcionam como m√°gica em linguagens como JavaScript, mas n√£o √© m√°gina, √© um /parser/ ancorado em uma gram√°tica fazendo o trabalho duro.

Primeiro, permita-me ilustrar uma gram√°tica simples para representar arquivos JSON (ref):

#+begin_src antlr

  json: object
  	| array
  	;

  object: '{' pair (',' pair)* '}'
  	  | '{' '}' // empty object
  	  ;
  pair: STRING ':' value ;

  array: '[' value (',' value)* ']'
  	 | '[' ']' // empty array
  	 ;

  value: STRING
  	 | NUMBER
  	 | object // recursion
  	 | array  // recursion
  	 | 'true' // keywords
  	 | 'false'
  	 | 'null'
  	 ;
     
#+end_src

Na gram√°tica acima podemos visualizar os elementos de um objeto JSON:

- =json= √© o pr√≥prio objeto JSON composto de objetos ou arrays;
- =object= √© uma estrutura entre chaves que pode conter 0 ou mais pares;
- =pair= √© uma estrutura de chave e valor, a chave sendo uma string;
- =array= √© uma estrutura entre colchetes que pode conter 0 ou mais valore;
- =value= √© um valor primitivo - string, n√∫mero ou palavras chave - ou um valor composto como um objeto ou array.

TODO - Explicar processo de constru√ß√£o da parse tree

Com uma vis√£o geral de compildares, voltamo-nos agora ao dicion√°rio. Obviamente n√£o criei um compilador do zero, utilizei ferramentas existentes para me auxiliar neste processo. Uma ferramenta muito conhecida no mundo Java √© o [[https://www.antlr.org/][ANTLR]], criado por Terence Parr, tech lead no Google. O ANTRL permite a gera√ß√£o de /parsers/ para a tradu√ß√£o, execu√ß√£o ou processamento de arquivos de texto estruturado ou bin√°rios. Tudo o que o ANTLR precisa √© de uma gram√°tica, a partir disso a ferramenta gera um Parser baseado em /Design Patterns/ como Visitor que pode ser usado para a solu√ß√£o do problema em m√£os como: gerar um mapa de tradu√ß√µes.

Para a cria√ß√£o da gram√°tica √© preciso identificar a estrutura do dicion√°rio, vejamos um exemplo:
#+DOWNLOADED: screenshot @ 2024-07-06 19:57:57
[[file:Estruturando_o_texto_em_um_mapa_de_tradu√ß√µes/2024-07-06_19-57-57_screenshot.png]]

Estamos interessados em dois elementos: a palavra de origem e sua tradu√ß√£o. Do exemplo acima podemos extrair a seguinte estrutura:

- Palavra de origem;
- Classe gramatical;
- Contexto;
- Tradu√ß√£o;
- Sexo;
- =;= seguido de exemplos.

Por sorte, tudo o que n√£o nos interessa para a resolu√ß√£o do problema √© demarcado com um =;= facilitando a defini√ß√£o da gram√°tica. A partir dessa estrutura podemos definir uma gram√°tica inicial na linguagem utilizada pelo ANTLR:

#+begin_src antlr
  
  grammar EnPtDictionary;

  compilationUnit: (entry '\n'?)* EOF ;

  entry: enWord context? grammaticalClass ptWord examples ;

  context: '(' .*? ')' ;

  grammaticalClass: 'adj' 'adv'?
                  | 'adj' 'pp'?
                  | 'adv'
                  | 'npr' 'adj'?
                  | 'n' 'adj'?
                  | 'pp' 'adj'?
                  | 'prep'
                  | 'vr'
                  | 'vt' ('/' 'vi')?
                  | 'vt' (',' 'vi')?
                  | 'vt' ('/' 'vr')?
                  | 'vt' (',' 'vr')?
                  | 'vi'
                  ;

  enWord: word ;
  ptWord: word SEX? ;
  word: WORD | '\n' ;

  examples: ';' .*? '.' '\n'
          | '.' '\n'
          ;

  NUMBER: DIGIT+ ;
  fragment DIGIT: '0'..'9' ;

  SEX: 'm' (',' 'f')? | 'f' ;
  COMMA: ',' ;
  WORD: [a-zA-Z]+ ;

  WS: [ \t\r]+ -> skip ;

#+end_src

Elementos como sexo e contexto n√£o aparecem em todas as entradas do dicion√°rio, por isso s√£o definidos como opcionais utilizando o caractere =?=. Para detalhes da liguagem de defini√ß√£o da gram√°tica, consulte a [[https://github.com/antlr/antlr4/blob/master/doc/grammars.md][documenta√ß√£o]].

Com mais um exemplo podemos perceber que temos uma lista de tradu√ß√µes:
#+DOWNLOADED: screenshot @ 2024-07-06 20:25:20
[[file:Estruturando_o_texto_em_um_mapa_de_tradu√ß√µes/2024-07-06_20-25-20_screenshot.png]]

Podemos atender esse requisito com algumas modifica√ß√µes na gram√°tica:
#+begin_src antlr

  entry: enWord context? grammaticalClass ptWord+ examples ;
  word: WORD | COMMA | '\n' ;
  COMMA: ',' ;
    
#+end_src

Ap√≥s algumas itera√ß√µes voc√™ ter√° a gram√°tica atendendo suas necessidadesAp√≥s algumas itera√ß√µes voc√™ ter√° a gram√°tica atendendo suas necessidades. Detalhes sangrentos como o tratamento de caracteres especiais foram mantidos de fora dos exemplos para facilitar o entendimento. TODO talvez subir no GitHub e referenciar aqui.

Com a gram√°tica pronta podemos gerar o /parser/:

#+begin_src shell
  java -cp "/tools/antlr-4.13.1-complete.jar:$CLASSPATH" org.antlr.v4.Tool -visitor -o ../src/main/java/antlr -package antlr EnPtGrammar
#+end_src

- =-cp= adiciona o ANTLR ao classath;
- =-visitor= instrui o comando para gerar o /parser/ com o /Design Pattern Visitor/;
- =-o= especifica o diret√≥rio de sa√≠da para as classes geradas;
- =-package= especifica que todas as classes geradas devem conter a declara√ß√£o =package antlr;=.

Ap√≥s a execu√ß√£o do comando, voc√™ ter√° a seguinte estrutura:
#+DOWNLOADED: screenshot @ 2024-07-06 20:51:19
[[file:Estruturando_o_texto_em_um_mapa_de_tradu√ß√µes/2024-07-06_20-51-19_screenshot.png]]

De todos estes arquivos, o que nos interessa √© a classe Java =EnPtDicionaryBaseVisitor=, √© uma implementa√ß√£o padr√£o do /parser/. Para cada elemento da gram√°tica temos um m√©todo na forma =visitElement(var cx)= que podemos sobreescrever:

#+begin_src java

  class EnPtDictionary extends EnPtDictionaryBaseVisitor<Void> {
      @Override
      public Void visitEntry(EnPtDictionaryParser.EntryContext ctx) {
          String enWord = ctx.enWord().getText();
          List<String> ptWords = ctx.ptWord().stream()
  			.map(RuleContext::getText)
  			.toList();
          return super.visitEntry(ctx);
      }
  }

#+end_src

E pronto, agora para cada entrada do dicion√°rio, temos acesso a palavra de origem e a lista de tradu√ß√µes, podemos realizar qualquer processamento necess√°rio n√£o tratado na gram√°tica e ent√£o colocar em um mapa. A partir deste mapa um arquivo JSON pode ser criado para servir como base de dados do aplicativo que pode rodar completamente offline.

Esse √© apenas um exemplo de problema que pode ser resolvido com tecnologias oriundas dos estudos de compildores. Basta utilizar a criatividade.

Isso √© tudo pessoal üê∞ü•ï!
