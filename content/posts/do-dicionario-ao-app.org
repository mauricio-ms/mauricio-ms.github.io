#+TITLE: Do dicion√°rio ao App: Como digitalizar um dicion√°rio em PDF utilizando Compiladores
#+DATE: <2024-08-11>
#+COVER: /blog/do-dicionario-ao-app/cover.jpg

Neste post, lhes contarei a saga de como digitalizei o PDF de um dicion√°rio para a cria√ß√£o de um App para o estudo de vocabul√°rio utilizando compiladores.

J√° fazem muitos anos que n√£o tenho dificuldade nas leituras em Ingl√™s de livros t√©cnicos, e isso tem um motivo, o vocabul√°rio destes livros √© altamente especializado, uma vez compreendido e pronto, a maioria dos livros podem ser lidos sem grandes dificuldades. O mesmo n√£o √© verdade toda vez que inicio estudos de outros assuntos, como: literatura, filosofia, hist√≥ria ou economia. Ao adentrar em um novo campo de conhecimento me pego parando a leitura in√∫meras vezes para traduzir o vocabul√°rio do livro. Durante a leitura, normalmente recorro a ferramentas de tradu√ß√£o online. Neste processo, adiciono a maioria das palavras ao meu vocabul√°rio sem grandes dificuldades, no entanto, notei que para um pequeno conjunto de palavras muito espec√≠ficas tenho mais dificuldades, pesquiso pela mesma palavra in√∫meras vezes antes de decor√°-la, ou seja, lembro que j√° pesquisei pela tradu√ß√£o de determinadas palavras, embora ainda n√£o lembre de seus significados. Criei listas de palavras para decor√°-las mas logo percebi o qu√£o ineficiente era este processo, ent√£o meu instinto de programador pensou em uma √∫nica coisa: automa√ß√£o.

A maneira mais eficiente que encontrei de obter o significado de palavras durante a leitura sem perder o foco, foi utilizando aplicativos de tradu√ß√£o. Sendo assim, o que eu preciso √© de um aplicativo similar, mas que mantenha uma mem√≥ria das palavras que tenho mais dificuldade e que me permita treinar o aprendizado destas palvras de alguma forma. A partir disso, projetei a cria√ß√£o de um aplicativo para:

- Replicar a experi√™ncia de aplicativos de tradu√ß√£o com os quais estou acostumado;
- Adicionar a funcionalidade de treinamento:
  - Cada palavra pesquisada deve ser adicionada a uma lista de palavras para treinamento com um contador do n√∫mero de pesquisas associado - para possibilitar a cria√ß√£o de uma lista de prioridade das palavras que mais tenho dificuldade;
  - Na tela de treinamento, cada erro ou acerto deve atualizar o contador de erros daquela palavra at√© ao ponto em que a palavra pode ser removida da lista de treinamento.

A implementa√ß√£o de um aplicativo como este √© razoavelmente simples, basta obter alguma API de tradu√ß√£o - de alguma plataforma tradicional, ou j√° que estamos em tempos de IA, de alguma API baseada em um modelo /LLM/. No entanto, eu defini alguns requisitos que precisavam ser atendidos:

- O aplicativo n√£o deve gerar custos financeiros;
- A implementa√ß√£o deve ser divertida ü•∏.

Bem, a implementa√ß√£o via API n√£o se encaixa em nenhum destes requisitos üòÖ. N√£o demorei muito para perceber que n√£o era necess√°rio a implementa√ß√£o de um sistema de tradu√ß√£o completo, mas de um simples dicion√°rio, uma vez que quero realizar a tradu√ß√£o de palavras e n√£o de senten√ßas completas. Esta constata√ß√£o simplifica por ordens de grandeza o problema. Procurei por dicion√°rios digitalizados na internet, mas n√£o encontrei nada muito completo, era preciso digitalizar um dicion√°rio. Este problema pode ser resolvido em duas etapas, converter o PDF do dicion√°rio em texto, e a partir do texto gerar um mapa com a estrutura: ~entrada do dicion√°rio => lista de tradu√ß√µes~.

* Transformando PDF em texto

Tentei n√£o perder muito tempo com esta etapa recorrendo a ferramentas online, mas n√£o demorei muito para perceber um problema, dicion√°rios s√£o divididos em 2 colunas, e estas ferramentas n√£o entendem isso:

#+DOWNLOADED: screenshot @ 2024-07-06 17:52:50
#+CAPTION: Estrutura b√°sica de um dicion√°rio
#+ATTR_HTML: :alt Estrutura b√°sica de um dicion√°rio
[[file:Transformando_PDF_em_texto/2024-07-06_17-52-50_screenshot.png]]

O texto √© gerado considerando arquivos normais sem subdivis√£o em um mesma p√°gina. O que eu precisava era, para cada p√°gina, gerar o texto da coluna da esquerda e depois o da coluna da direita. A biblioteca [[https://itextpdf.com/][iText]] permite realizar este processamento de forma muito simples, basta definir √°reas representando cada coluna para realizar a extra√ß√£o dos textos separadamente. A classe em Java abaixo demonstra como realizar a convers√£o de um dicion√°rio em PDF para um arquivo texto especificando os limites via constantes e as p√°ginas de interesse via par√¢metros do m√©todo /convertToText/:

#+begin_src java
  import com.itextpdf.text.Rectangle;
  import com.itextpdf.text.pdf.PdfReader;
  import com.itextpdf.text.pdf.parser.*;

  import java.io.FileOutputStream;
  import java.io.IOException;

  class PdfConverter {
      private static final byte[] NL = "\n".getBytes();

      private static final int VERTICAL_MARGIN = 38;
      private static final int X_MAX = 432;
      private static final int Y_MAX = 663;
  	
      public void convertToText(int startPage, int endPage) throws IOException {
          PdfReader reader = new PdfReader("input-file.pdf");
          float middlePdfPage = ((float) X_MAX / 2) + 2;
          var leftColumn = new Rectangle(0, VERTICAL_MARGIN, middlePdfPage, Y_MAX - VERTICAL_MARGIN);
          var rightColumn = new Rectangle(middlePdfPage, VERTICAL_MARGIN, X_MAX, Y_MAX - VERTICAL_MARGIN);

          try (var outStream = new FileOutputStream("out-file.txt")) {
              for (int i = startPage; i <= endPage; i++) {
                  outStream.write(extractText(reader, leftColumn, i).getBytes());
                  outStream.write(NL);
                  outStream.write(extractText(reader, rightColumn, i).getBytes());
                  outStream.write(NL);
              }
          }
      }

      private String extractText(PdfReader reader, Rectangle region, int pageNumber) throws IOException {
          RenderFilter[] filter = {new RegionTextRenderFilter(region)};
  	  var extractionStrategy = new LocationTextExtractionStrategy(); 
          var strategy = new FilteredTextRenderListener(extractionStrategy, filter);
          return PdfTextExtractor.getTextFromPage(reader, pageNumber, strategy);
      }
  }
#+end_src

* Estruturando o texto em um mapa de tradu√ß√µes

√â nesta etapa que a divers√£o come√ßa. Dicion√°rios tem uma estrutura muito bem definida e cientistas da computa√ß√£o sabem h√° d√©cadas como analisar este tipo de texto: compiladores. Um exemplo disso s√£o linguagens de programa√ß√£o, independente de qual voc√™ utilize, por tr√°s dela sempre haver√° um compilador ou um interpretador.

Linguagens compiladas precisam de um compilador para transformar seu programa em uma linguagem de m√°quina que o computador possa executar. Antes da execu√ß√£o do programa, todo o c√≥digo √© traduzido (compilado) para uma linguagem de mais baixo n√≠vel. Compiladores completos realizam a tradu√ß√£o para uma linguagem de montagem como Assembly. No entanto, uma vez que existem compiladores extremamente maduros para linguagens como C, uma abordagem mais simples √© realizar a tradu√ß√£o para uma linguagem intermedi√°ria como C, e aproveitar-se de otimiza√ß√µes existentes nestes compiladores para a gera√ß√£o do c√≥digo de linguagem de m√°quina.

No caso de linguagens interpretadas, n√£o existe um compilador, mas sim um interpretador que interpreta cada comando fornecido para a gera√ß√£o de um resultado.

Compiladores utilizam-se de gram√°ticas para analisar textos estruturados. O processo consiste na constru√ß√£o de uma /Syntax Tree/ que representa o conte√∫do do programa de acordo com os elementos da gram√°tica. Um exemplo simples para ilustrar todo esse processo √© a an√°lise de objetos JSON, funcionam como m√°gica em linguagens como JavaScript, mas n√£o √© m√°gica, √© um /parser/ ancorado em uma gram√°tica fazendo o trabalho duro.

Primeiro, permita-me ilustrar uma gram√°tica simples para representar arquivos JSON (Parr, 2013):

#+begin_src antlr
  json: object
  	| array
  	;

  object: '{' pair (',' pair)* '}'
  	  | '{' '}' // empty object
  	  ;
  pair: STRING ':' value ;

  array: '[' value (',' value)* ']'
  	 | '[' ']' // empty array
  	 ;

  value: STRING
  	 | NUMBER
  	 | object // recursion
  	 | array  // recursion
  	 | 'true' // keywords
  	 | 'false'
  	 | 'null'
  	 ;     
#+end_src

Na gram√°tica acima podemos visualizar os elementos de um objeto JSON:

- =json= √© o pr√≥prio objeto JSON composto de objetos ou arrays;
- =object= √© uma estrutura entre chaves que pode conter 0 ou mais pares;
- =pair= √© uma estrutura de chave e valor, a chave sendo uma string;
- =array= √© uma estrutura entre colchetes que pode conter 0 ou mais valores;
- =value= √© um valor primitivo - string, n√∫mero ou palavras chave - ou um valor composto como um objeto ou array.

Com a gram√°tica definida, o compilador precisa analisar o programa para garantir que este respeita a estrutura definida na gram√°tica e realizar a tradu√ß√£o para a linguagem destino. Este trabalho √© definido em um conjunto de componentes que vamos analisar brevemente com a ajuda do temido livro do drag√£o üêâüî• (Aho et al., 2006).

** Analisador L√©xico:
O analisador l√©xico √© o primeiro componente de um compilador, ele √© respons√°vel pelo processamento do texto do programa na linguagem de origem. A sa√≠da deste componente √© um conjunto de tokens na estrutura: =<token,value>=.

*Exemplo*:

C√≥digo-fonte: =price = base + rate * 15=

Tokens: =<id,1> <=> <id,2> <+> <id,3> <*> <15>=

Onde cada =token= √© um s√≠mbolo abstrato e =value= aponta para uma entrada em uma /Symbol Table/ - uma estrutura de dados utilizada em todas as fases do compilador para armazenar dados do programa.

** Analisador Sint√°tico:
A partir dos tokens gerados pelo analisador l√©xico, o analisador sint√°tico gera uma /Syntax Tree/ para representar a estrutura do programa. /Syntax Tree's/ s√£o amplamente utilizadas por IDE's e editores de texto para apontarem erros de sintaxe.

A /Syntax Tree/ do exemplo acima pode ser representada da seguinte forma:

#+CAPTION: Exemplo de Syntax Tree
#+ATTR_HTML: :alt Exemplo de Syntax Tree
[[file:Estruturando_o_texto_em_um_mapa_de_tradu√ß√µes/assignment-example.png]]

** Analisador Sem√¢ntico:
O analisador sem√¢ntico utiliza os dados armazendos na /Symbol table/ e a /Syntax Tree/ para analisar a consist√™ncia sem√¢ntica do programa de acordo com a defini√ß√£o da linguagem na gram√°tica. Esta etapa realiza tarefas como checagem de tipos e promo√ß√£o de tipos - caso a linguagem sendo analisada permita.

Se a vari√°vel =rate= do exemplo fosse do tipo ponto flutuante, a /Syntax Tree/ produzida pelo analisador sem√¢ntico seria enriquecida com a promo√ß√£o do valor =15= de =int= para =float=:

#+CAPTION: Exemplo de Syntax Tree com promo√ß√£o de tipo
#+ATTR_HTML: :alt Exemplo de Syntax Tree com promo√ß√£o de tipo
[[file:Estruturando_o_texto_em_um_mapa_de_tradu√ß√µes/assignment-type-promotion-example.png]]

** Gera√ß√£o de c√≥digo intermedi√°rio:
Com a /Syntax Tree/ pronta, √© chegado o momento de produzir c√≥digo em uma representa√ß√£o intermedi√°ria. Este c√≥digo deve ser simples de produzir e de converter em c√≥digo de m√°quina, de modo a simplificar e tornar eficientes os pr√≥ximos componentes do compilador. Um tipo comum de representa√ß√£o intermedi√°ria √© o c√≥digo de tr√™s endere√ßos: uma sequ√™ncia de instru√ß√µes /assembly-like/ com tr√™s operandos por instru√ß√£o.

A representa√ß√£o em c√≥digo de tr√™s endere√ßos para o exemplo seria algo assim:

#+begin_src asm
  t1 = intToFloat(15)
  t2 = id3 * t1
  t3 = id2 + t2
  id1 = t3
#+end_src

** Otimiza√ß√£o de c√≥digo:
A partir da representa√ß√£o intermedi√°ria, in√∫meras otimiza√ß√µes podem ser aplicadas de forma a tornar o c√≥digo mais eficiente.

Seguindo com o exemplo, o conjunto de instru√ß√µes gerado na etapa anterior poderia ser reduzido removendo a convers√£o expl√≠cita de =int= para =float=:

#+begin_src asm
  t1 = id3 * 15.0
  id1 = id2 + t1
#+end_src

** Gera√ß√£o de c√≥digo:
Com o c√≥digo intermedi√°rio otimizado, √© hora da gera√ß√£o do c√≥digo na linguagem destino. Caso esta seja linguagem de m√°quina, o c√≥digo gerado poderia ser um Assembly como este:

#+begin_src asm
  LDF  R2, id3
  MULF R2, R2, #15.0
  LDF  R1, id2
  ADDF R1, R1, R2
  STD id1, R1
#+end_src

Em cada opera√ß√£o:
- O primeiro operando especifica o destino.
- O =F= indica que a opera√ß√£o trabalha com operandos de ponto flutuante.

** De volta ao dicion√°rio
Com uma vis√£o geral de compiladores, voltemo-nos agora ao dicion√°rio. Obviamente n√£o criei um compilador do zero, utilizei ferramentas existentes para me auxiliar neste processo. Uma ferramenta muito conhecida no mundo Java √© o [[https://www.antlr.org/][ANTLR]]. O ANTRL permite a gera√ß√£o de /parsers/ para a tradu√ß√£o, execu√ß√£o ou processamento de arquivos de texto estruturado ou bin√°rios. Tudo o que o ANTLR precisa √© de uma gram√°tica, a partir disso a ferramenta gera um /parser/ baseado em /Design Patterns/ como o /Visitor/ que pode ser utilizado para a solu√ß√£o do problema, como por exemplo: gerar um mapa de tradu√ß√µes.

Para a cria√ß√£o da gram√°tica, √© preciso identificar a estrutura do dicion√°rio, vejamos um exemplo:
#+DOWNLOADED: screenshot @ 2024-07-06 19:57:57
#+CAPTION: Exemplo de uma entrada de um dicion√°rio
#+ATTR_HTML: :alt Exemplo de uma entrada de um dicion√°rio
[[file:Estruturando_o_texto_em_um_mapa_de_tradu√ß√µes/2024-07-06_19-57-57_screenshot.png]]

Estamos interessados em dois elementos: a palavra de origem e sua tradu√ß√£o. Do exemplo acima podemos extrair a seguinte estrutura:

- Palavra de origem;
- Classe gramatical;
- Contexto;
- Tradu√ß√£o;
- Sexo;
- =;= seguido de exemplos.

Por sorte, tudo o que n√£o nos interessa para a resolu√ß√£o do problema √© demarcado com um =;= facilitando a defini√ß√£o da gram√°tica. A partir dessa estrutura podemos definir uma gram√°tica inicial na linguagem utilizada pelo ANTLR:

#+begin_src antlr
  grammar EnPtDictionary;

  compilationUnit: (entry '\n'?)* EOF ;

  entry: enWord context? grammaticalClass ptWord examples ;

  context: '(' .*? ')' ;

  grammaticalClass: 'adj' 'adv'?
                  | 'adj' 'pp'?
                  | 'adv'
                  | 'npr' 'adj'?
                  | 'n' 'adj'?
                  | 'pp' 'adj'?
                  | 'prep'
                  | 'vr'
                  | 'vt' ('/' 'vi')?
                  | 'vt' (',' 'vi')?
                  | 'vt' ('/' 'vr')?
                  | 'vt' (',' 'vr')?
                  | 'vi'
                  ;

  enWord: word ;
  ptWord: word SEX? ;
  word: WORD | '\n' ;

  examples: ';' .*? '.' '\n'
          | '.' '\n'
          ;

  NUMBER: DIGIT+ ;
  fragment DIGIT: '0'..'9' ;

  SEX: 'm' (',' 'f')? | 'f' ;
  COMMA: ',' ;
  WORD: [a-zA-Z]+ ;

  WS: [ \t\r]+ -> skip ;
#+end_src

Elementos como sexo e contexto n√£o aparecem em todas as entradas do dicion√°rio, por isso s√£o definidos como opcionais utilizando o caractere =?=. Para detalhes da liguagem de defini√ß√£o da gram√°tica, consulte a [[https://github.com/antlr/antlr4/blob/master/doc/grammars.md][documenta√ß√£o]].

Com mais um exemplo, percebemos que uma palavra de tradu√ß√£o n√£o √© o suficente, precisamos de uma lista de tradu√ß√µes, que √© nada mais que palavras separadas por v√≠rgula:
#+DOWNLOADED: screenshot @ 2024-07-06 20:25:20
#+CAPTION: Exemplo de uma entrada de um dicion√°rio com m√∫ltiplas tradu√ß√µes
#+ATTR_HTML: :alt Exemplo de uma entrada de um dicion√°rio com m√∫ltiplas tradu√ß√µes
[[file:Estruturando_o_texto_em_um_mapa_de_tradu√ß√µes/2024-07-06_20-25-20_screenshot.png]]

Podemos atender esse requisito com algumas modifica√ß√µes na gram√°tica:
#+begin_src antlr
  entry: enWord context? grammaticalClass ptWord+ examples ;
  word: WORD | COMMA | '\n' ;
  COMMA: ',' ;
#+end_src

Neste exemplo estou simplificando ao m√°ximo e incluindo a v√≠rgula como uma palavra, sendo assim, no /parser/ ser√° necess√°rio remover palavras que s√£o v√≠rgulas. Isto poderia ser tratado na gram√°tica, mas serve para ilustrar que a gram√°tica n√£o precisa estar perfeita para resolver o seu problema, muita coisa pode ser resolvida no /parser/.

Ap√≥s algumas itera√ß√µes melhorando a gram√°tica voc√™ ter√° uma que atenda as suas necessidades. Detalhes sangrentos como o tratamento de caracteres especiais foram mantidos de fora dos exemplos para facilitar o entendimento. A implementa√ß√£o completa voc√™ encontra no meu [[https://github.com/mauricio-ms/dictionary-parser][GitHub]].

Com a gram√°tica pronta podemos gerar o /parser/:

#+begin_src shell
  java -cp "/tools/antlr-4.13.1-complete.jar:$CLASSPATH" org.antlr.v4.Tool -visitor -o ../src/main/java/antlr -package antlr EnPtGrammar
#+end_src

- =-cp= adiciona o ANTLR ao classath;
- =-visitor= instrui o comando para gerar o /parser/ com o /Design Pattern Visitor/;
- =-o= especifica o diret√≥rio de sa√≠da para as classes geradas;
- =-package= especifica que todas as classes geradas devem conter a declara√ß√£o =package antlr;=.

Ap√≥s a execu√ß√£o do comando, voc√™ ter√° a seguinte estrutura:
#+DOWNLOADED: screenshot @ 2024-07-06 20:51:19
#+CAPTION: Estrutura do projeto ap√≥s a compila√ß√£o da gram√°tica
#+ATTR_HTML: :alt Estrutura do projeto ap√≥s a compila√ß√£o da gram√°tica
[[file:Estruturando_o_texto_em_um_mapa_de_tradu√ß√µes/2024-07-06_20-51-19_screenshot.png]]

De todos estes arquivos, o que nos interessa √© a classe Java =EnPtDicionaryBaseVisitor=, que √© uma implementa√ß√£o padr√£o do /parser/. Para cada elemento da gram√°tica temos um m√©todo com a assinatura =visitElement(var cx)= que podemos sobreescrever:

#+begin_src java
  class EnPtDictionary extends EnPtDictionaryBaseVisitor<Void> {
      @Override
      public Void visitEntry(EnPtDictionaryParser.EntryContext ctx) {
          String enWord = ctx.enWord().getText();
          List<String> ptWords = ctx.ptWord().stream()
  			.map(RuleContext::getText)
  			.toList();
          return super.visitEntry(ctx);
      }
  }
#+end_src

E pronto, agora para cada entrada do dicion√°rio, temos acesso a palavra de origem e a lista de tradu√ß√µes, podemos realizar qualquer processamento necess√°rio n√£o tratado na gram√°tica - como a remo√ß√£o das v√≠rgulas - e ent√£o colocar os resultados em um mapa. A partir deste mapa, um arquivo JSON pode ser criado para servir como base de dados do aplicativo que pode rodar completamente offline.

Para quem chegou at√© aqui e est√° se perguntando se o tal aplicativo foi de fato criado, sim, foi, e est√° sendo extremamente √∫til nas minhas leituras üìö.

Esse √© apenas um exemplo de problema que pode ser resolvido com tecnologias oriundas dos estudos de compiladores. Basta utilizar a sua criatividade.

Isso √© tudo pessoal üê∞ü•ï!

*Refer√™ncias*

Parr, T. (2013). Definitive ANTLR 4 Reference (2nd ed.). Pragmatic Programmers.

Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). Compilers: Principles, techniques, and tools (2nd ed.). Pearson.
